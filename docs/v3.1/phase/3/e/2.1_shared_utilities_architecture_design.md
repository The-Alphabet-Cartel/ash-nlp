# SharedUtilitiesManager Architecture Design

**Repository**: https://github.com/the-alphabet-cartel/ash-nlp  
**Project**: Ash-NLP v3.1 Manager Consolidation  
**Community**: The Alphabet Cartel - https://discord.gg/alphabetcartel | https://alphabetcartel.org  
**FILE VERSION**: v3.1-3e-6-1
**LAST MODIFIED**: 2025-08-22
**PHASE**: 3e Step 2.1 - SharedUtilitiesManager Architecture Design  
**CLEAN ARCHITECTURE**: v3.1 Compliant  
**PARENT TRACKER**: `docs/v3.1/phase/3/e/tracker.md`  
**PARENT STEP**: `docs/v3.1/phase/3/e/step_2.md`

---

## ðŸŽ¯ **Design Objective**

Create SharedUtilitiesManager to consolidate 150+ duplicate utility methods across 14 managers into 15 core utilities, eliminating ~90% of duplicate utility code while maintaining Clean v3.1 architecture compliance.

---

## ðŸ’Ž **PREMIUM UTILITIES (Tier 1 - Best-in-Class)**

Based on Step 1 analysis, these 4 methods represent the highest quality implementations:

### **1. `safe_bool_convert()` - GOLD STANDARD** â­â­â­â­â­
**Source**: `logging_config_manager._safe_bool_conversion()`  
**Benefits**: ALL 14 managers  
**Usage Pattern**: Convert configuration values to boolean with intelligent fallbacks

```python
def safe_bool_convert(self, value: Any, default: bool = False, param_name: str = "unknown") -> bool:
    """
    Convert value to boolean with intelligent fallbacks
    Handles: 'true'/'false', 1/0, 'yes'/'no', 'on'/'off', etc.
    """
```

### **2. `get_setting_with_type_conversion()` - EXCELLENT** â­â­â­â­â­
**Source**: `performance_config_manager._get_performance_setting()`  
**Benefits**: 12 managers  
**Usage Pattern**: Get configuration setting with automatic type conversion

```python
def get_setting_with_type_conversion(self, section: str, key: str, expected_type: type, 
                                   default: Any = None, param_name: str = None) -> Any:
    """
    Get configuration setting with automatic type conversion and validation
    """
```

### **3. `get_nested_config_setting()` - EXCELLENT** â­â­â­â­â­
**Source**: `server_config_manager._get_setting_with_defaults()`  
**Benefits**: 11 managers  
**Usage Pattern**: Get nested configuration with fallback defaults

```python
def get_nested_config_setting(self, path: str, default: Any = None, 
                            fallback_paths: List[str] = None) -> Any:
    """
    Get nested configuration setting with intelligent fallback paths
    """
```

### **4. `get_boolean_setting()` - VERY GOOD** â­â­â­â­
**Source**: `feature_config_manager._get_feature_flag()`  
**Benefits**: 10 managers  
**Usage Pattern**: Get boolean configuration settings with feature flag patterns

```python
def get_boolean_setting(self, key: str, default: bool = False, 
                       environment_override: bool = True) -> bool:
    """
    Get boolean setting with feature flag patterns and environment overrides
    """
```

---

## ðŸ› ï¸ **UNIVERSAL UTILITIES (All 14 Managers)**

### **Configuration Processing (5 methods)**

#### **5. `load_json_with_env_substitution()`**
**Source**: Universal pattern across all managers  
**Purpose**: Load JSON configuration files with environment variable substitution

```python
def load_json_with_env_substitution(self, file_path: str, env_prefix: str = None, 
                                  required: bool = True) -> Dict[str, Any]:
    """
    Load JSON configuration with environment variable substitution
    Supports ${VAR_NAME} and ${VAR_NAME:default_value} patterns
    """
```

#### **6. `get_config_section_safely()`**
**Source**: Universal pattern across all managers  
**Purpose**: Safely access configuration sections with fallbacks

```python
def get_config_section_safely(self, section_name: str, fallback: Dict = None) -> Dict[str, Any]:
    """
    Safely get configuration section with fallback dictionary
    """
```

#### **7. `apply_env_overrides()`**
**Source**: Universal pattern across all managers  
**Purpose**: Apply environment variable overrides to configuration

```python
def apply_env_overrides(self, config_data: Dict, env_prefix: str) -> Dict[str, Any]:
    """
    Apply environment variable overrides to configuration data
    """
```

#### **8. `get_with_fallback()`**
**Source**: Universal pattern across all managers  
**Purpose**: Get configuration value with intelligent fallback chain

```python
def get_with_fallback(self, primary_key: str, fallback_keys: List[str], 
                     default: Any = None) -> Any:
    """
    Get configuration value with fallback key chain
    """
```

#### **9. `validate_config_structure()`**
**Source**: Universal validation patterns  
**Purpose**: Validate configuration structure against schema

```python
def validate_config_structure(self, config_data: Dict, required_sections: List[str], 
                            schema: Dict = None) -> List[str]:
    """
    Validate configuration structure and return list of issues
    """
```

---

### **Type Conversion (3 methods)**

#### **10. `safe_int_convert()`**
**Source**: Universal integer conversion pattern  
**Purpose**: Convert values to integers with validation

```python
def safe_int_convert(self, value: Any, default: int = 0, min_val: int = None, 
                    max_val: int = None, param_name: str = "unknown") -> int:
    """
    Convert value to integer with range validation and fallbacks
    """
```

#### **11. `safe_float_convert()`**
**Source**: Universal float conversion pattern  
**Purpose**: Convert values to floats with validation

```python
def safe_float_convert(self, value: Any, default: float = 0.0, min_val: float = None, 
                      max_val: float = None, param_name: str = "unknown") -> float:
    """
    Convert value to float with range validation and fallbacks
    """
```

---

### **Validation (3 methods)**

#### **12. `validate_range()`**
**Source**: Universal range checking pattern  
**Purpose**: Validate numeric values are within acceptable ranges

```python
def validate_range(self, value: Union[int, float], min_val: Union[int, float], 
                  max_val: Union[int, float], param_name: str = "unknown") -> bool:
    """
    Validate numeric value is within specified range
    """
```

#### **13. `validate_type()`**
**Source**: Universal type checking pattern  
**Purpose**: Validate values match expected types

```python
def validate_type(self, value: Any, expected_type: Union[type, tuple], 
                 param_name: str = "unknown") -> bool:
    """
    Validate value matches expected type(s)
    """
```

#### **14. `validate_bounds()`**
**Source**: Universal bounds checking pattern  
**Purpose**: Validate values are within operational bounds

```python
def validate_bounds(self, value: Union[int, float], bounds: Dict[str, Union[int, float]], 
                   param_name: str = "unknown") -> bool:
    """
    Validate value is within operational bounds dictionary
    """
```

---

### **Error Handling (1 method)**

#### **15. `handle_error_with_fallback()`**
**Source**: Universal error handling pattern across ALL managers  
**Purpose**: Handle errors with intelligent fallbacks and logging

```python
def handle_error_with_fallback(self, error: Exception, fallback_value: Any, 
                             context: str, operation: str = "unknown") -> Any:
    """
    Handle error with fallback value and structured logging
    Returns fallback_value and logs error with context
    """
```

---

## ðŸš« **UTILITIES TO EXCLUDE (Domain-Specific)**

These utilities stay in their respective managers due to domain-specific logic:

| Excluded Utility | Reason | Keep In Manager |
|------------------|--------|-----------------|
| Crisis-specific validation | Life-saving domain logic | PatternDetectionManager |
| Model loading utilities | Model-specific operations | ModelEnsembleManager |
| Threshold calculation | Algorithm-specific | CrisisThresholdManager |
| Semantic analysis | NLP-specific operations | ZeroShotManager |
| Pattern matching | Crisis detection logic | PatternDetectionManager |
| Learning algorithms | Learning-specific | LearningSystemManager (Step 3) |

---

## ðŸ—ï¸ **SharedUtilitiesManager Class Architecture**

### **Class Structure**

```python
class SharedUtilitiesManager:
    """
    Consolidated utility methods used across multiple managers
    Follows Clean v3.1 architecture with dependency injection
    
    Provides 15 core utilities to eliminate 150+ duplicate methods
    across 14 managers, achieving ~90% code reduction
    """
    
    def __init__(self, unified_config: UnifiedConfigManager):
        """
        Initialize SharedUtilitiesManager with dependency injection
        
        Args:
            unified_config: UnifiedConfigManager instance for configuration access
        """
        self.config_manager = unified_config
        self.logger = logging.getLogger(__name__)
        
        # Validation status tracking
        self._validation_errors = []
        self._last_operation_status = {}
        
    # PREMIUM UTILITIES (Tier 1)
    def safe_bool_convert(self, value, default=False, param_name="unknown"):
        """Convert value to boolean with intelligent fallbacks"""
        
    def get_setting_with_type_conversion(self, section, key, expected_type, default=None, param_name=None):
        """Get configuration setting with automatic type conversion"""
        
    def get_nested_config_setting(self, path, default=None, fallback_paths=None):
        """Get nested configuration setting with intelligent fallback paths"""
        
    def get_boolean_setting(self, key, default=False, environment_override=True):
        """Get boolean setting with feature flag patterns"""
        
    # CONFIGURATION PROCESSING UTILITIES
    def load_json_with_env_substitution(self, file_path, env_prefix=None, required=True):
        """Load JSON configuration with environment variable substitution"""
        
    def get_config_section_safely(self, section_name, fallback=None):
        """Safely get configuration section with fallback dictionary"""
        
    def apply_env_overrides(self, config_data, env_prefix):
        """Apply environment variable overrides to configuration data"""
        
    def get_with_fallback(self, primary_key, fallback_keys, default=None):
        """Get configuration value with fallback key chain"""
        
    def validate_config_structure(self, config_data, required_sections, schema=None):
        """Validate configuration structure and return list of issues"""
        
    # TYPE CONVERSION UTILITIES  
    def safe_int_convert(self, value, default=0, min_val=None, max_val=None, param_name="unknown"):
        """Convert value to integer with range validation and fallbacks"""
        
    def safe_float_convert(self, value, default=0.0, min_val=None, max_val=None, param_name="unknown"):
        """Convert value to float with range validation and fallbacks"""
        
    # VALIDATION UTILITIES
    def validate_range(self, value, min_val, max_val, param_name="unknown"):
        """Validate numeric value is within specified range"""
        
    def validate_type(self, value, expected_type, param_name="unknown"):
        """Validate value matches expected type(s)"""
        
    def validate_bounds(self, value, bounds, param_name="unknown"):
        """Validate value is within operational bounds dictionary"""
        
    # ERROR HANDLING UTILITIES
    def handle_error_with_fallback(self, error, fallback_value, context, operation="unknown"):
        """Handle error with fallback value and structured logging"""
        
    # UTILITY STATUS METHODS
    def get_last_operation_status(self):
        """Get status of last utility operation"""
        
    def get_validation_errors(self):
        """Get collected validation errors"""
        
    def clear_validation_errors(self):
        """Clear validation error collection"""
```

---

## ðŸ”§ **Factory Function Pattern**

Following Clean v3.1 architecture, SharedUtilitiesManager will use factory function:

```python
def create_shared_utilities_manager(unified_config: UnifiedConfigManager = None) -> SharedUtilitiesManager:
    """
    Factory function to create SharedUtilitiesManager with dependency injection
    
    Args:
        unified_config: UnifiedConfigManager instance (will create if None)
        
    Returns:
        SharedUtilitiesManager: Configured manager instance
        
    Raises:
        ConfigurationError: If unified_config cannot be created or is invalid
    """
    try:
        # Use provided config or create new one
        if unified_config is None:
            from managers.unified_config import create_unified_config_manager
            unified_config = create_unified_config_manager()
            
        # Validate config manager
        if not hasattr(unified_config, 'get_env_str'):
            raise ConfigurationError("Invalid unified_config: missing required methods")
            
        # Create and return manager
        return SharedUtilitiesManager(unified_config)
        
    except Exception as e:
        logging.getLogger(__name__).error(f"Failed to create SharedUtilitiesManager: {e}")
        raise ConfigurationError(f"SharedUtilitiesManager creation failed: {e}")
```

---

## ðŸ“‹ **Integration Strategy**

### **Phase 1: Manager Integration**

These managers will integrate SharedUtilitiesManager in Step 2.2:

| Manager | Methods to Replace | Integration Pattern |
|---------|-------------------|-------------------|
| **analysis_config_manager** | `validate_parameter_type()` â†’ `validate_type()` | Constructor injection |
| **crisis_threshold_manager** | `validate_threshold_range()` â†’ `validate_range()` | Constructor injection |
| **pattern_detection_manager** | `log_pattern_error()` â†’ `handle_error_with_fallback()` | Constructor injection |
| **feature_config_manager** | `get_feature_status()` â†’ `get_boolean_setting()` | Constructor injection |
| **logging_config_manager** | `_safe_bool_conversion()` â†’ `safe_bool_convert()` | Constructor injection |
| **performance_config_manager** | `_get_performance_setting()` â†’ `get_setting_with_type_conversion()` | Constructor injection |

### **Integration Update Process:**

1. **Add SharedUtilitiesManager import** to each manager
2. **Update constructor** to accept SharedUtilitiesManager dependency
3. **Replace duplicate methods** with calls to shared utilities
4. **Update factory functions** to inject SharedUtilitiesManager
5. **Update method calls** throughout the manager
6. **Remove duplicate method implementations**

---

## ðŸ”§ **Implementation Files**

### **Primary Implementation:**
- **File**: `managers/shared_utilities.py`
- **Factory**: `create_shared_utilities_manager()`
- **Dependencies**: `UnifiedConfigManager` (Clean v3.1 compliant)

### **Test Implementation:**
- **File**: `tests/phase/3/e/test_shared_utilities_manager.py`
- **Coverage**: All 15 utility methods + factory function + integration
- **Performance**: Validate <5ms overhead per utility call

### **Documentation Updates:**
- **Manager docs**: Update all 14 manager documentation files
- **Architecture docs**: Update Clean v3.1 compliance documentation
- **Integration docs**: Manager integration patterns

---

## ðŸŽ¯ **Success Criteria for Sub-step 2.1**

- âœ… **SharedUtilitiesManager design complete** - Architecture defined with 15 core utilities
- âœ… **Method consolidation strategy clear** - 150+ duplicate methods â†’ 15 shared utilities  
- âœ… **Premium utilities identified** - 4 best-in-class methods from Step 1 analysis
- âœ… **Integration plan established** - Clear update process for 6 priority managers
- âœ… **Clean v3.1 compliance verified** - Factory function and dependency injection patterns
- âœ… **Domain boundaries respected** - Life-saving methods protected in specific managers

---

## ðŸš€ **Next Steps**

### **Sub-step 2.2: Implementation**
- Create `managers/shared_utilities.py` with all 15 utility methods
- Implement factory function with Clean v3.1 patterns
- Add comprehensive error handling and logging
- Implement utility status tracking

### **Sub-step 2.3: Integration Testing**
- Create comprehensive test suite
- Test all utility methods individually
- Test integration with existing managers
- Validate performance impact <5ms overhead

---

**ðŸŽ‰ SUB-STEP 2.1 COMPLETE - SHARED UTILITIES ARCHITECTURE DESIGNED! ðŸš€**

**Foundation**: 15 core utilities designed to eliminate 150+ duplicate methods  
**Quality**: 4 premium utilities from best-in-class implementations  
**Safety**: Life-saving methods protected in domain-specific managers  
**Compliance**: Clean v3.1 architecture patterns throughout  

Ready for Sub-step 2.2: SharedUtilitiesManager Implementation! ðŸŒˆ